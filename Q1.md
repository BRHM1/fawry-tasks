Reflective Section for mygrep.sh

1. Breakdown: How the script handles arguments and options

The script first checks if any options are passed by looking for arguments that start with a dash -.

It supports combined short options like -vn by splitting the characters and processing them individually inside a loop.

It sets flags (show_line_numbers, invert_match) based on the options detected.

After options are handled, the script expects two mandatory arguments:

The pattern to search for.

The file to search in.

It checks if enough arguments are provided and whether the given file exists.

During line-by-line reading:

It converts both the pattern and each line to lowercase to achieve case-insensitive matching.

It applies inversion if -v is set.

If -n is set, it prefixes matching lines with their line number.

If --help is passed, it displays a usage guide and exits.

✅ Overall, the script closely mimics basic grep behavior while supporting combination of options and proper error handling.

2. If I wanted to add support for regex, -i, -c, or -l, how would the structure change?

Regex Support:Replace the simple [[ "$line_lower" == "$pattern_lower" ]] check with:

if [[ "$line_lower" =~ $pattern_lower ]]; then

or internally use tools like awk or sed for complex regex handling.

``** (case-insensitive)**:Introduce an ignore_case flag and only apply lowercase transformations if -i is provided.

``** (count matches)**:Add a counter variable and instead of printing lines, just increment the counter when matches occur, and print the final count at the end.

``** (list filenames only if they match)**:Check for any match during processing, and after the file is read, print only the filename if there was at least one match.

✅ More options would require managing more internal state and adjusting output behavior.

3. What was the hardest part to implement and why?

The hardest part was handling combined options like -vn and -nv correctly.

Instead of treating each -$option separately, it required splitting the string character-by-character inside a loop.

Bash normally expects options to be separated, so manually parsing combined short flags needs careful logic.

Catching invalid options (like -z) immediately required extra validation inside the loop.

✅ Solving this improved my understanding of manual command-line parsing in Bash without using built-in parsers like getopts.

Bonus

The script already supports --help to print usage information.

